% !TeX spellcheck = en_US
\documentclass[12pt,a4paper]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathpazo}  % Palatino
\usepackage{geometry}
\geometry{top=2.6cm, bottom=2.3cm, left=1.75cm, right=1.75cm}

\usepackage{amsmath, amssymb}
\usepackage{graphicx, caption, subcaption}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=black,
	urlcolor=black,
	citecolor=black
}

\usepackage{fancyhdr}

\usepackage{graphicx, caption, subcaption}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}


% --- Colores personalizados ---
\definecolor{bashgreen}{rgb}{0.0,0.6,0.0}
\definecolor{bashred}{rgb}{0.6,0.0,0.0}
\definecolor{bashblue}{rgb}{0.0,0.0,0.8}
\definecolor{lightgray}{gray}{0.97}
\definecolor{gray}{gray}{0.4}
\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{purple}{rgb}{0.58,0,0.82}

% --- Estilo para Python ---
\lstdefinestyle{pythonstyle}{
	language=Python,
	backgroundcolor=\color{lightgray},
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\color{blue}\bfseries,
	stringstyle=\color{orange},
	commentstyle=\color{bashgreen}\itshape,
	numberstyle=\tiny\color{gray},
	numbers=left,
	stepnumber=1,
	showstringspaces=false,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=2,
	frame=single,
	rulecolor=\color{gray},
}

% --- Estilo para Bash ---
\lstdefinestyle{bashstyle}{
	language=bash,
	backgroundcolor=\color{lightgray},
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\color{bashblue}\bfseries,
	stringstyle=\color{orange},
	commentstyle=\color{bashgreen}\itshape,
	numberstyle=\tiny\color{gray},
	numbers=left,
	stepnumber=1,
	showstringspaces=false,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4,
	frame=single,
	rulecolor=\color{gray},
}

% --- Colores para estilo consola ---
\definecolor{terminalbg}{rgb}{1,1,1}
\definecolor{terminaltext}{rgb}{0.9,0.9,0.9}
\definecolor{terminalgreen}{rgb}{0.5,1,0.5}
\definecolor{terminalblue}{rgb}{0.5,0.7,1}
\definecolor{terminalorange}{rgb}{1,0.7,0.4}
\definecolor{terminalgray}{gray}{0.5}

% --- Estilo tipo consola Bash ---
\lstdefinestyle{bashconsole}{
	language=bash,
	backgroundcolor=\color{terminalbg},
	basicstyle=\ttfamily\footnotesize\color{terminaltext},
	keywordstyle=\color{terminalblue}\bfseries,
	stringstyle=\color{terminalorange},
	commentstyle=\color{terminalgreen}\itshape,
	showstringspaces=false,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4,
	frame=single,
	rulecolor=\color{terminalgray},
	frameround=tttt,
	xleftmargin=0pt,
	framexleftmargin=5pt,
	framexrightmargin=5pt,
	framextopmargin=5pt,
	framexbottommargin=5pt,
}



% --- Prefijo para mostrar prompt "$ " en cada línea ---
\lstset{
	literate={\$}{{\textcolor{terminalgreen}{\$}}}1,
}

% --- Colores para consola sobre fondo blanco ---
\definecolor{terminalbg}{rgb}{1,1,1}          % fondo blanco
\definecolor{terminaltext}{rgb}{0,0,0}        % texto negro
\definecolor{terminalgreen}{rgb}{0,0.6,0}     % prompt $
\definecolor{terminalblue}{rgb}{0,0,0.8}      % keywords/commands
\definecolor{terminalorange}{rgb}{1,0.5,0}    % strings
\definecolor{terminalgray}{gray}{0.5}         % marco

% --- Estilo Bash tipo consola fondo blanco ---
\lstdefinestyle{bashconsolewhite}{
	language=bash,
	backgroundcolor=\color{terminalbg},
	basicstyle=\ttfamily\footnotesize\color{terminaltext},
	keywordstyle=\color{terminalblue}\bfseries,
	stringstyle=\color{terminalorange},
	commentstyle=\color{terminalgreen}\itshape,
	showstringspaces=false,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4,
	frame=single,
	rulecolor=\color{terminalgray},
	frameround=tttt,
	xleftmargin=0pt,
	framexleftmargin=5pt,
	framexrightmargin=5pt,
	framextopmargin=5pt,
	framexbottommargin=5pt,
	showspaces=false,
	columns=fullflexible,    % ← AÑADE ESTO
	keepspaces=true,         % ← AÑADE ESTO
	basewidth=0.5em
}

% --- Prefijo para mostrar prompt "$ " en verde ---
\lstset{
	literate={\$}{{\textcolor{terminalgreen}{\$}}}1,
	showspaces=false,
	showtabs=false,
	showstringspaces=false,
	upquote=true
}



\usepackage{amsmath, amssymb}

\pagestyle{fancy}
\fancyhead[L]{Technical Report}
\fancyhead[R]{\thepage}
\fancyfoot{}

\title{
    \begin{center}
        \textbf{Task 1 Perception \\ Planning and Perception Module} \\
        \vspace{0.3cm}
        {\large Diploma in Robotics}
    \end{center}
}


\author{Brayan Gerson Duran Toconas}
\date{\today}

%ros2 topic pub /target geometry_msgs/msg/Point "{x: 0.5, y: -0.5, z: 0.12}" --once

%ros2 topic pub /target geometry_msgs/msg/Point "{x: 0.3, y: 0.3, z: 0.4}" --once

\begin{document}
	
	\maketitle
	\tableofcontents
	\listoffigures
	\newpage
	
	\section{Introduction}
	This report presents the image–processing pipeline used to detect and track the color markers of an autonomous soccer robot. The procedure includes Gaussian-based color thresholding, masking operations, circle detection, and the application of a Kalman filter to obtain a stable and reliable estimation of the robot's position.
	
	
	%\section{Installation of Package}
	\section*{Procedure}
	Only the most relevant and significant parts of the code will be described, focusing on their functionality.\\
	
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Read the video},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	cap=cv2.VideoCapture(args.video_path)\end{lstlisting}
	
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Select the colour to calculate mean and covariance},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	def select_color_model(frame):
	    r = cv2.selectROI("Seleccione la pelota", frame, fromCenter=False, showCrosshair=True)
	    x, y, w, h = r
	    roi = frame[y:y+h, x:x+w]
	
	    hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
	    pixels = hsv_roi.reshape((-1, 3))
	
	    mean = np.mean(pixels, axis=0)
	    cov = np.cov(pixels, rowvar=False)
	
	    print("Media HSV:", mean)
	    print("Covarianza HSV:", cov)
	
	    cv2.destroyWindow("Seleccione la pelota")
	
	    return mean, cov
	    
	print("Mark the colors...")
	    for c in range(len(colors)):
	        print(f"Color {c+1}: {colors[c]}")
	
	        for i in range(args.captures):
	            print(f"Captura {i+1} de {args.captures}")
	            frame_number=int(input(f"Frame number of {int(cap.get(cv2.CAP_PROP_FRAME_COUNT))}: "))
	            try:
	                cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
	                ret, frame=cap.read()
	            except:
	                print("Error: Not valid frame number")
	                continue
	            
	            if not ret:
	                print("Error: No se pudo leer el frame")
	                continue
	            men_i,cov_i=ball_tracker.select_color_model(frame)
	            means[c].append(men_i)
	            covs[c].append(cov_i)\end{lstlisting}
	
	
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Traing the gaussian mask from mean and covariance},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	mean_hsv[c] = np.mean(means[c], axis=0)
	cov_hsv[c] = np.mean(covs[c], axis=0)
	hsv=cv2.cvtColor(frame,cv2.COLOR_BGR2HSV)
	combined_mask = np.zeros(hsv.shape[:2], dtype=np.uint8)
	for c in range(len(colors)):
		masks[c] = ball_tracker.gaussian_mask(hsv, mean_hsv[c], cov_hsv[c], args.threshold)
		masks[c]=cv2.erode(masks[c],kernel,iterations=1)
		masks[c]=cv2.dilate(masks[c],kernel,iterations=2)
		combined_mask = cv2.bitwise_or(combined_mask, masks[c])
	frame_masked=cv2.bitwise_and(frame,frame,mask=combined_mask)\end{lstlisting}
	
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Individual color contour detections: all green contours are shown, along with one representative contour for blue and red.
	},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	for i, (name, color) in enumerate(draw_info):
	            contours, _ = cv2.findContours(masks[i], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
	            if contours:
	                if name != "Green":
	                    c = max(contours, key=cv2.contourArea) # max
	                    ((x, y), radius) = cv2.minEnclosingCircle(c)
	                    print(radius)
	                    if radius > 9.0 and radius < 15.5: # 0.005
	                        detected[name] = True
	                        measured_x[name] = int(x)
	                        measured_y[name] = int(y)
	                        # Dibujo en pantalla
	                        cv2.circle(frame, (measured_x[name], measured_y[name]), int(radius), color, 2)
	                        cv2.putText(frame, name, (measured_x[name] + 10, measured_y[name]),cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)
	                else:
	                    for c in contours:
	                        ((x, y), radius) = cv2.minEnclosingCircle(c)
	                        if radius > 8.0 and radius < 15.2:
	                            detected[name] = True
	                            if measured_x[name] is None:
	                                measured_x[name] = []
	                                measured_y[name] = []
	                            measured_x[name].append(int(x))
	                            measured_y[name].append(int(y))
	                            cv2.circle(frame, (int(x), int(y)), int(radius),color, 2)
	                            cv2.putText(frame, name, (int(x) + 10, int(y)), cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)\end{lstlisting}
	
	
	
	
	
	
	
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Prediction and marking of the color and robot positions using a Kalman filter.
	},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	kalman_positions = {}
	        for name, tracker in trackers.items():
	            if name in ["Red", "Blue"]:
	                pred_x, pred_y = tracker.predict()
	                if detected[name]:
	                    mx = measured_x[name]
	                    my = measured_y[name]
	                    tracker.correct(mx, my)
	                    current_pos = (mx, my)
	                else:
	                    current_pos = (pred_x, pred_y)
	                    cv2.putText(frame, f"{name} P(Ocluido)", (int(pred_x) + 10, int(pred_y)),
	                                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
	                kalman_positions[name] = current_pos
	                # Dibujo del marcador del Kalman
	                cv2.drawMarker(frame, (int(current_pos[0]), int(current_pos[1])), (0, 0, 255), cv2.MARKER_CROSS, 20, 2)
	            elif name == "Green":
	                if detected[name]:
	                    mx_list = measured_x[name]
	                    my_list = measured_y[name]
	                    if isinstance(mx_list, list):
	                        for x, y in zip(mx_list, my_list):
	                             cv2.drawMarker(frame, (x, y), (0, 0, 255), cv2.MARKER_TILTED_CROSS, 15, 2)\end{lstlisting}
	
	
	\begin{lstlisting}[language=Bash, caption={Tree of packages},basicstyle=\ttfamily\small]
		tree -L 1 src/
		src/
		├── kinematics_mh12
		└── yaskawa_robot
	\end{lstlisting}
	
	Next, from the root directory of the workspace, verify the installation of all dependencies using the following command:  
	\texttt{rosdep update \&\& rosdep install}\verb| --from-paths src|
	
	Alternatively, you can install the dependencies manually using \texttt{pip}:  
	\texttt{pip3 install sympy numpy scipy pyyaml} adding the \verb|--break-system-packages| flag if required by your system.
	Finally, compile the workspace using:  
	\texttt{colcon build \&\& source install/setup.bash}
	
	
	\section{Forward Kinematics}
	Forward kinematics determines the position of the end-effector as a function of the robot's joint angles.  
	This position and orientation corresponds to the total homogeneous transformation matrix $T$, also referred to as $M$ in the PoE method.
	
	The following section presents the interpretation of the reference frames and rotations used in the kinematic model.
	\subsection{References Axis}
	Figure~\ref{fig:axis} presents a comprehensive view of the robot's kinematic model, including all the annotations and reference frames necessary for applying the PoE method. This figure serves as a visual guide for understanding the orientation and position of each joint as well as the end-effector, facilitating the implementation of both forward and inverse kinematics calculations.
	
	\begin{figure}[htbp]
		\centering
		%\includegraphics[width=0.95\textwidth]{ilustration_axis_annotated.pdf}
		\caption{Robot with the reference frames illustrated}
		\label{fig:axis}
	\end{figure}
	\newpage
	
	\subsection{Screw Axes}
	\begin{equation}
		s_1: \quad 
		\mathbf{w} = 
		\begin{bmatrix}
			0 \\ 0 \\ 1
		\end{bmatrix}, \quad
		\mathbf{q} = 
		\begin{bmatrix}
			0 \\ 0 \\ 0.44999998807907104
		\end{bmatrix}
	\end{equation}
	
	\begin{equation}
		s_2: \quad 
		\mathbf{w} = 
		\begin{bmatrix}
			0 \\ 1 \\ 0
		\end{bmatrix}, \quad
		\mathbf{q} = 
		\begin{bmatrix}
			0.1550000011920929 \\ 0 \\ 0.44999998807907104
		\end{bmatrix}
	\end{equation}
	
	\begin{equation}
		s_3: \quad 
		\mathbf{w} = 
		\begin{bmatrix}
			0 \\ -1 \\ 0
		\end{bmatrix}, \quad
		\mathbf{q} = 
		\begin{bmatrix}
			0.15487676858901978 \\ 0 \\ 1.0640000104904175
		\end{bmatrix}
	\end{equation}
	
	\begin{equation}
		s_4: \quad 
		\mathbf{w} = 
		\begin{bmatrix}
			0 \\ 1 \\ 0
		\end{bmatrix}, \quad
		\mathbf{q} = 
		\begin{bmatrix}
			0.7949622273445129 \\ 0 \\ 1.2637263536453247
		\end{bmatrix}
	\end{equation}
	
	\begin{equation}
		s_5: \quad 
		\mathbf{w} = 
		\begin{bmatrix}
			-1 \\ 0 \\ 0
		\end{bmatrix}, \quad
		\mathbf{q} = 
		\begin{bmatrix}
			0.7949622273445129 \\ 0 \\ 1.2637263536453247
		\end{bmatrix}
	\end{equation}
	
	\begin{equation}
		M =
		\begin{bmatrix}
			0 & 0 & 1 & 0.8949621915817261 \\
			0 & 1 & 0 & 0 \\
			-1 & 0 & 0 & 1.263683557510376 \\
			0 & 0 & 0 & 1
		\end{bmatrix}
	\end{equation}
	
	
	
	\subsection{Procedure to Execute the Forward Kinematics Program}
	To run the forward kinematics, execute the following command.  
	After running it, the position and orientation values of the end-effector will start printing in the same terminal.
	
	\noindent
	\begin{lstlisting}[style=bashconsolewhite,language=Bash, caption={Command to run forward kinematics},xleftmargin=15pt,xrightmargin=20pt,basicstyle=\ttfamily\small,breaklines=true, breakatwhitespace=true,columns=fixed,prebreak=\mbox{\tiny$\rhook$},
	    postbreak=\mbox{\tiny$\rightarrow$},showspaces=false,showspaces=false,showtabs=false,showstringspaces=false]
$ ros2 launch kinematics_mh12 launch_mode.launch.py mode:=forward
	\end{lstlisting}
	
	The previous command will launch a preconfigured \texttt{RViz2} session along with the \texttt{Joint State Publisher} graphical interface.  
	Additionally, the position and orientation of the end-effector will be continuously displayed in the same terminal from which the launch was executed.
	
	
	
	
	\section{Inverse Kinematics}
	The inverse kinematics was solved using the total homogeneous transformation matrix $T$, whose last column $(T_{0,3},\, T_{1,3},\, T_{2,3})$ represents the translation components $p_x$, $p_y$, and $p_z$.  
	These elements define the position equations of the end-effector as functions of the robot’s joint variables $(\theta_1,\, \theta_2,\, \theta_3,\, \theta_4,\, \theta_5)$.  
	
	From these equations, the Jacobian matrix and its inverse are derived and used in an iterative gradient-based approach to reach the target position by minimizing the error.  
	The joint update control law is defined as:
	
	\[
	\theta_i = \theta_i + \alpha \, \Delta\theta
	\]
	
	While minimizing the approximation error, the real-time joint state of the robot is published as follows:
	
	\noindent
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Real-time joint state publishing},xleftmargin=20pt,xrightmargin=20pt,breaklines=true, breakatwhitespace=true]
	joint_msg.name = ['joint_1_s', 'joint_2_l', 'joint_3_u', 'joint_4_r', 'joint_5_b', 'joint_6_t']
		
	joint_angles = [ti[0], ti[1], ti[2], 0.0, -ti[3], ti[4]]
	\end{lstlisting}
	
	In this configuration, \texttt{joint\_4\_r} is fixed to zero since it has no mobility.  
	The \texttt{joint\_5\_b} angle is inverted due to its opposite orientation in the model, while the last joint, \texttt{joint\_6\_t}, maintains rotation because there is a small displacement along the $z$-axis between joints \texttt{j5} and \texttt{j4}.
	
	
	
	
	
	\subsection{Procedure to Execute the Inverse Kinematics Program}
	
	To execute the inverse kinematics, the same package uses the same launch file with an additional argument to specify the mode. It can be started as follows:
	
	\noindent
	\begin{lstlisting}[style=bashconsolewhite,language=Bash, caption={Command to run inverse kinematics},xleftmargin=15pt,xrightmargin=10pt,basicstyle=\ttfamily\small,breaklines=true, breakatwhitespace=true]
$ ros2 launch kinematics_mh12 launch_mode.launch.py mode:=inverse
	\end{lstlisting}
	
	To define the target position, open another terminal within the same \texttt{ROS\_DOMAIN\_ID} and execute the following command:
	
	\begin{lstlisting}[style=bashconsolewhite,language=Bash, caption={Command to publish a target point},xleftmargin=10pt,xrightmargin=10pt,columns=fullflexible,keepspaces=true,basicstyle=\ttfamily\small,breaklines=true, breakatwhitespace=true]
$ ros2 topic pub /target geometry_msgs/msg/Point "{x: 0.3, y: 0.3, z: 0.3}" --once
	\end{lstlisting}
	
	If the message is published correctly, the first terminal (where the inverse kinematics was launched) will begin displaying the real-time approximation of the joint values as the error decreases. This process typically takes about 2 to 3 minutes. Once the iteration converges, an information message will indicate that the target has been successfully reached, after which a new target can be sent.
	
	
	
	
	
	\section{Discussion and Results}
	The analysis is considered valid, as the results obtained from both forward and inverse kinematics demonstrate high accuracy.  
	For forward kinematics, the difference between the estimated values and those visualized in \texttt{RViz2} is approximately $\pm 0.0001$, while for inverse kinematics the difference is even smaller, around $\pm 0.0001$.  
	
	The following Figure \ref{fig:sub1_en}, \ref{fig:sub2_en}, \ref{fig:sub3_en}, \ref{fig:sub4_en} provide visual evidence supporting the correct operation of both methods:
	
	\begin{figure}[htpb]
		\centering
		\begin{subfigure}[b]{0.7\textwidth}
			\centering
			%\includegraphics[width=\textwidth]{fw_rviz.png}
			\caption{RViz2}
			\label{fig:sub1_en}
		\end{subfigure}
		\vfill
		\begin{subfigure}[b]{0.7\textwidth}
			\centering
			%\includegraphics[width=\textwidth]{fw_terminal.png}
			\caption{Forward kinematics}
			\label{fig:sub2_en}
		\end{subfigure}
		\caption{Comparison of forward kinematics values}
		\label{fig:forward}
	\end{figure}
	
	\begin{figure}[htpb]
		\centering
		\begin{subfigure}[b]{0.7\textwidth}
			\centering
			%\includegraphics[width=\textwidth]{inv_rviz.png}
			\caption{RViz2}
			\label{fig:sub3_en}
		\end{subfigure}
		\vfill
		\begin{subfigure}[b]{0.7\textwidth}
			\centering
			%\includegraphics[width=\textwidth]{inv_terminal.png}
			\caption{Inverse kinematics}
			\label{fig:sub4_en}
		\end{subfigure}
		\caption{Comparison of inverse kinematics values}
		\label{fig:inverse}
	\end{figure}

	
	
	\section{Conclusion}
	
	In conclusion, the implementation of the PoE method for determining the robot's kinematics was successful. This is supported by the low errors obtained in both forward and inverse kinematics, as well as by meeting all the deliverable requirements specified in the project guidelines.
	
	
	\newpage
	\appendix
	\section{Codes}
	
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Forward code of Python},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	#ROS 2 PoE Node.
	
	import rclpy
	from rclpy.node import Node
	from sensor_msgs.msg import JointState
	
	import sympy as sp
	from sympy import symbols, Matrix, eye, sin, cos, pprint, pi
	import os
	import yaml
	import numpy as np
	from scipy.spatial.transform import Rotation as R_quat
	
	# -- Symbols definition
	theta = symbols('theta', real=True)
	w0, w1, w2 = symbols('omega_0 omega_1 omega_2', real=True)
	qx, qy, qz = symbols('q_x q_y q_z', real=True)
	L1, L2, L3 = symbols('L_1 L_2 L_3', real=True)
	t1, t2, t3, t4, t5 = symbols('theta_1 theta_2 theta_3 theta_4 theta5', real=True)
	
	# Symbolic twist axis
	w = Matrix([w0, w1, w2])
	
	# Skew-symmetric matrix
	skew_w = Matrix([
	    [0, -w[2], w[1]],
	    [w[2], 0, -w[0]],
	    [-w[1], w[0], 0]
	])
	
	# Rodrigues / Exponential map pieces
	R = eye(3) + sin(theta)*skew_w + (1 - cos(theta))*(skew_w**2)
	v = -skew_w*Matrix([[qx], [qy], [qz]])
	Rv = (eye(3)*theta + (1 - cos(theta))*(skew_w) + (theta - sin(theta))*(skew_w**2)) * v
	
	# Homogeneous Transform
	T_elem = Matrix([[R[0,0], R[0,1], R[0,2], Rv[0]],
	                 [R[1,0], R[1,1], R[1,2], Rv[1]],
	                 [R[2,0], R[2,1], R[2,2], Rv[2]],
	                 [0, 0, 0, 1]])
	
	# Symbolic quaternion components (tool)
	qtx, qty, qtz, qtw = symbols('q_tool_x q_tool_y q_tool_z q_tool_w', real=True)
	
	# Normalize quaternion (to be safe if the numeric inputs are not normalized)
	norm_q = sp.sqrt(qtx**2 + qty**2 + qtz**2 + qtw**2)
	qx_n = qtx / norm_q
	qy_n = qty / norm_q
	qz_n = qtz / norm_q
	qw_n = qtw / norm_q
	
	# Rotation matrix from normalized quaternion (qw is scalar part)
	Rot_tool = Matrix([
	    [1 - 2*(qy_n**2 + qz_n**2),     2*(qx_n*qy_n - qz_n*qw_n),     2*(qx_n*qz_n + qy_n*qw_n)],
	    [2*(qx_n*qy_n + qz_n*qw_n),     1 - 2*(qx_n**2 + qz_n**2),     2*(qy_n*qz_n - qx_n*qw_n)],
	    [2*(qx_n*qz_n - qy_n*qw_n),     2*(qy_n*qz_n + qx_n*qw_n),     1 - 2*(qx_n**2 + qy_n**2)]
	])
	
	# Definitions of the tool quaternion and position values
	# Numeric defaults for the tool quaternion (qx,qy,qz,qw) - unit quaternion
	# represents no rotation.
	TOOL_QX = -1.89428046581952e-08
	TOOL_QY = 0.7072578072547913
	TOOL_QZ = 1.8950899516312347e-08
	TOOL_QW = 0.7069556713104248
	
	# Build the 4x4 M with the tool rotation and the previously used translation
	M_sym = sp.eye(4)
	for i in range(3):
	    for j in range(3):
	        M_sym[i, j] = Rot_tool[i, j]
	# translation values from original M
	M_sym[0, 3] = 0.8949621915817261
	M_sym[1, 3] = 0.0
	M_sym[2, 3] = 1.263683557510376
	
	# Definition of M (pose end-effector at  home)
	# Substitute numeric tool quaternion so FK depends only on joint angles
	M = sp.N(M_sym.subs({qtx: TOOL_QX, qty: TOOL_QY, qtz: TOOL_QZ, qtw: TOOL_QW}))
	#pprint(M)
	
	# Transfrorms for each joint and screws (axis and point)
	T1 = T_elem.subs({theta: t1, w0: 0, w1: 0, w2: 1, qx: 0, qy: 0, qz: 0.44999998807907104})
	T2 = T_elem.subs({theta: t2, w0: 0, w1: 1, w2: 0, qx: 0.1550000011920929, qy: 0, qz: 0.44999998807907104})
	T3 = T_elem.subs({theta: t3, w0: 0, w1: -1, w2: 0, qx: 0.15487676858901978, qy: 0, qz: 1.0640000104904175})
	T4 = T_elem.subs({theta: t4, w0: 0, w1: 1, w2: 0, qx: 0.7949622273445129, qy: 0, qz: 1.2637263536453247})
	T5 = T_elem.subs({theta: t5, w0: -1, w1: 0, w2: 0, qx: 0.7949622273445129, qy: 0, qz: 1.2637263536453247})
	
	# Final Transform for the robot
	T_sym = sp.expand(T1 * T2 * T3 * T4 * T5 * M)
	
	# Save symbolic matrix to a YAML file
	def save_symbolic_matrix(matrix, filename):
	    matrix_data = {
	        'shape': matrix.shape,
	        'elements': [[str(matrix[i,j]) for j in range(matrix.shape[1])] 
	                    for i in range(matrix.shape[0])]
	    }
	    os.makedirs(os.path.dirname(filename), exist_ok=True)
	    with open(filename, 'w') as f:
	        yaml.dump(matrix_data, f, default_flow_style=False)
	
	matrix_file = os.path.join('data', 'T_sym_matrix.yaml')
	os.makedirs('data', exist_ok=True)
	
	save_symbolic_matrix(T_sym, matrix_file)
	
	pprint(T_sym)
	
	# Lambdify for numeric evaluation
	fk_func = sp.lambdify((t1, t2, t3, t4, t5), T_sym, modules=['numpy'])
	
	class PoEfwMH12Node(Node):
	    def __init__(self):
	        super().__init__('poe_mh12_node')
	        # Default joint values
	        self.j1 = 0.0
	        self.j2 = 0.0
	        self.j3 = 0.0
	        self.j4 = 0.0
	        self.j5 = 0.0
	
	        # Subscription `joint_states`
	        self.sub = self.create_subscription(JointState, 'joint_states', self.cb_joint_states, 10)
	
	        self.get_logger().info('Nodo PoE RRR iniciado. Suscrito a: /joint_states')
	
	    def cb_joint_states(self, msg: JointState):
	        #Callback for search JointState names.
	        try:
	            names = list(msg.name)
	            positions = list(msg.position)
	        except Exception:
	            self.get_logger().warn('Mensaje JointState sin campos name/position válidos')
	            return
	        def get_by_name(n):
	            if n in names:
	                idx = names.index(n)
	                if idx < len(positions):
	                    return float(positions[idx])
	            return None
	        # correct joint name (URDF uses 'joint_1_s')
	        v1s = get_by_name('joint_1_s')
	        v2l = get_by_name('joint_2_l')
	        v3u = get_by_name('joint_3_u')
	        v5b = get_by_name('joint_5_b')
	        v6t = get_by_name('joint_6_t')
	
	        # Fallback:
	        if v1s is None or v2l is None or v3u is None or v5b is None or v6t is None:
	            if len(positions) >= 5:
	                if v1s is None:
	                    v1s = float(positions[0])
	                if v2l is None:
	                    v2l = float(positions[1])
	                if v3u is None:
	                    v3u = float(positions[2])
	                if v5b is None:
	                    v5b = float(positions[3])
	                if v6t is None:
	                    v6t = float(positions[4])
	            else:
	                self.get_logger().warn('JointState no contiene suficientes posiciones y no se encontraron nombres esperados')
	                return
	        self.j1 = v1s
	        self.j2_= v2l
	        self.j3 = v3u
	        self.j4 = v5b
	        self.j5 = v6t
	        self._recompute_and_print()
	
	    def _recompute_and_print(self):
	        # Call to fk_func for the numeric evaluation
	        
	        j1 = getattr(self, 'j1', 0.0)
	        j2 = getattr(self, 'j2_',0.0)
	        j3 = getattr(self, 'j3', 0.0)
	        j4 = getattr(self, 'j4', 0.0)
	        j5 = getattr(self, 'j5', 0.0)
	        try:
	            T_num = fk_func(j1, j2, j3, j4, j5)
	        except Exception as e:
	            self.get_logger().error(f'Error al evaluar fk_func: {e}')
	            return
	
	        # numpy 4x4
	        T_np = np.array(T_num, dtype=float)
	        pos = T_np[0:3, 3]
	
	        # Rotations 3x3 -> cuaternión (x, y, z, w)
	        rot_mat = T_np[0:3, 0:3]
	        try:
	            rotation = R_quat.from_matrix(rot_mat)
	            quat = rotation.as_quat()
	        except Exception as e:
	            self.get_logger().error(f'Error al convertir matriz a cuaternión: {e}')
	            return
	
	        #Position: [x, y, z]
	        self.get_logger().info(f'Posición: x={pos[0]:.6f}, y={pos[1]:.6f}, z={pos[2]:.6f}')
	        # Quaternion: [x, y, z, w]
	        self.get_logger().info(f'Cuaternión: x={quat[0]:.6f}, y={quat[1]:.6f}, z={quat[2]:.6f}, w={quat[3]:.6f}')
	
	def main(args=None):
	    rclpy.init(args=args)
	    node = PoEfwMH12Node()
	    try:
	        rclpy.spin(node)
	    except KeyboardInterrupt:
	        pass
	    finally:
	        node.destroy_node()
	        rclpy.shutdown()
	if __name__ == '__main__':
	    main()
	\end{lstlisting}
	\newpage
	\begin{lstlisting}[style=pythonstyle,language=Python, caption={Inverse code of Python},columns=fullflexible,keepspaces=true,breakatwhitespace=true,breaklines=true]
	import rclpy
	from rclpy.node import Node
	from std_msgs.msg import Header
	from sensor_msgs.msg import JointState
	from geometry_msgs.msg import Point
	
	from sympy import Matrix, symbols, cos, sin, pi, diff, lambdify, pprint
	import numpy as np
	import math
	from random import random 
	from kinematics_mh12.fw_kinematics_mh12 import T_sym
	
	#-Old symbols definitions
	#t1=symbols('t1')
	#t2=symbols('t2')
	#t3=symbols('t3')
	#t4=symbols('t4')
	#t5=symbols('t5')
	
	# New symbols definitions
	t1, t2, t3, t4, t5 = symbols('theta_1 theta_2 theta_3 theta_4 theta5', real=True)
	
	# Learning parameters
	alpha=0.06  #learning rate 0.07
	iterations = 255  #350
	
	def create_jacobian(T_sym, thetas):
	    # Get position elements from the transformation matrix T_sym
	    px = T_sym[0,3]
	    py = T_sym[1,3]
	    pz = T_sym[2,3]
	
	    # Create a dinamic Jacobian matrix
	    J_rows = []
	    # For each position component
	    for p in [px, py, pz]:
	        # Parcial derivatives w.r.t. each theta
	        row = [diff(p, theta) for theta in thetas]
	        J_rows.append(row)
	    return Matrix(J_rows)
	
	# Get the list of joint variables
	thetas = [t1, t2, t3, t4, t5] 
	
	# Create jacobian symbolically
	px = T_sym[0,3]
	py = T_sym[1,3]
	pz = T_sym[2,3]
	J = create_jacobian(T_sym, thetas)
	
	class invKinematicsMH12Node(Node):
	    def __init__(self):
	        super().__init__('inverse_mh12_node')
	        self.subscription = self.create_subscription(Point, 'target', self.sub_callback,10)
	        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)
	        self.subscription
	        self.get_logger().info('Node inverse started')
	        
	    def sub_callback(self,msg):
	        driffz=0.0004
	        driffxy=0.0003
	        target=Matrix([msg.x,msg.y,msg.z])
	        self.get_logger().info('Received target: x={:.3f}, y={:.3f}, z={:.3f}'.format(msg.x, msg.y, msg.z))
	        ##target += np.sign(target) * driffxy
	        
	        for i in [0, 1]:
	            target[i] += np.sign(target[i]) * driffxy
	            '''
	            if target[i]>0:
	                target[i] += driffxy
	            else:
	                target[i] -= driffxy
	        '''    
	        target[2] += np.sign(target[2]) * driffz 
	
	        ti=Matrix([random(),random(),random(),random(),random()])
	        if hasattr(self, 'last_ti'):
	            ti = self.last_ti
	        else:
	            ti = Matrix([0, 0, 0, 0, 0])
	
	        for i in range(iterations):
	            # Evaluate forward position and Jacobian numerically
	            try:
	
	                cp = Matrix([
	                px.subs([(t1, ti[0]), (t2, ti[1]), (t3, ti[2]), (t4, ti[3]), (t5, ti[4])]),
	                py.subs([(t1, ti[0]), (t2, ti[1]), (t3, ti[2]), (t4, ti[3]), (t5, ti[4])]),
	                pz.subs([(t1, ti[0]), (t2, ti[1]), (t3, ti[2]), (t4, ti[3]), (t5, ti[4])])])
	                Jsubs = J.subs([(t1, ti[0]), (t2, ti[1]), (t3, ti[2]), (t4, ti[3]), (t5, ti[4])])
	
	                e = (target - cp)
	                
	                #e = e / max(1.0, e.norm())  
	            
	                Jinv=Jsubs.H*(Jsubs*Jsubs.H)**-1
	                #Jinv = (Jsubs.T * Jsubs + 0.01 * Matrix.eye(5))**-1 * Jsubs.T
	
	                dt=Jinv*e
	
	                ti=ti+alpha*dt
	
	            except Exception as exc:
	                self.get_logger().error(f'Numeric evaluation failed at iter {i}: {exc}')
	                break
	            # Build and publish final JointState (6 joints expected by other parts;  joint_4_r fixed to 0)
	            header = Header()
	            header.stamp = self.get_clock().now().to_msg()
	            joint_msg = JointState()
	
	            joint_msg.name = ['joint_1_s', 'joint_2_l', 'joint_3_u', 'joint_4_r', 'joint_5_b', 'joint_6_t']
	
	            joint_angles = [ti[0], ti[1], ti[2], 0.0, -ti[3], ti[4]]
	            
	            joint_msg.position = joint_angles
	            joint_msg.header = header
	            self.publisher_.publish(joint_msg)
	            self.get_logger().info('Published joint angles: {}'.format(joint_angles))
	            self.get_logger().info('Error: {:.6f}'.format(e.norm()))
	        self.get_logger().info('Finished IK iterations for target.')
	        self.last_ti = ti
	
	def main(args=None):
	    rclpy.init(args=args)
	    node = invKinematicsMH12Node()
	    try:
	        rclpy.spin(node)
	    except KeyboardInterrupt:
	        pass
	    finally:
	        node.destroy_node()
	        rclpy.shutdown()
	if __name__ == '__main__':
	    main()
	\end{lstlisting}
	
	
	%\bibliographystyle{ieeetr}
	%\bibliography{referencias}
	
\end{document}
